# How to learn programming languages

Currently in the field where the masses deliberately learn skills. I think the two most difficult areas should be "learning programming languages" and "learning foreign languages".

These two subjects are two skills that everyone wants to learn, but are actually difficult to learn.

You might be wondering, the approach of this book: can it also be used to break through these two fields of study?

The answer is yes. Even these two methods of learning can be the same.

## The essence of programming is "automation"

The common fears of the public about these two disciplines are:

- Too many proper nouns to memorize
- The grammar is too difficult and easy to make mistakes

Therefore, it is not enough to learn twice the result with half the effort, and it is directly from the entry to the result of giving up.

But I think this is because the vast majority of books in the market have taken the wrong angle of entry and took everyone a long way.

how to say. Let me start by asking readers, why do you want to learn a programming language?

Before many people want to learn programming, the first question is: which language should I learn?

Popular areas in the market are Python, Ruby, JAVA, JavaScript, Objective-C / Swift. Which set to choose.

Those who have already started will tell you:

\*Learn from me

- Or depending on your needs

But this usually has several consequences:

Beginners don't know what their needs are. How do you know what to choose? To make matters worse, it took him a long time to learn the language before he realized he couldn't do what he wanted. (For example, after learning Python, I can't create a mobile phone program, but I learned a lot of crawler technology)

This is usually the dead end of learning programming for beginners.

In addition, when we train new programmers, we will also encounter a problem. The other party is obviously proficient in grammar, but he does not know how to implement the code required by business logic, which makes the veteran very headache.

It was only later that I discovered that those who wanted to learn programming, and those who were teaching programming, had all misunderstood the biggest point of the programming technology: "automation".

Yes, automated.

Who of us doesn't want to learn programming without wanting to automate repetitive things on our hands? "Automation" is what we really want to do, isn't it?

There are many kinds of programming languages ​​in the world (on the order of a hundred). But the key purpose for which these programming languages ​​were invented and put into use is "automation".

If you start with grammar, not an "automated" process. It is very possible to do 100 times less with less effort.

## How to learn to automate

I mentioned the concept of programming thinking in my last book "Building a Superhuman Mind". Many people think of "programming" as a magical set of magic that can solve a very large problem.

In fact, programming is more like an automatic production line of multiple sets of gadgets.

When senior programmers actually design a set of programs, the main principle is to break down the problem first, find the parts that can be automated first, and use manual workround for the parts that cannot be automated, and then reassemble.

![](images/20211024113542.png)

### The automated process is input, processing, output

So how to automate it? In fact, the process is very simple: it is "input, processing, output" loop execution.

2020 on my whim. I want to do a simpler programming class (directly called "programming class without programming"), and the original textbooks are all written. But I'm not sure if the textbook I've written is suitable for everyone.

So I sent out a questionnaire asking everyone what problems they wanted to solve. I was stunned when the questionnaire was returned. The problem that everyone wants to solve is completely different from what I think. Naturally, my previous textbooks will be obsolete.

Everyone raised some questions that they wanted to solve.

Such as:

- After receiving various payment slips, the payment will be made automatically
- Printing factory telephone inquiry quotation
- The pharmacist receives the prescription and fills the medicine to remind the patient to come back to get the medicine
- Business visit, received business card, follow-up
- Propose with customers, arrange teacher teaching,
- Organize company bills and analyze budget spending
- Patient consultation, judgment and classification, follow-up health education tracking
- Tourism guests sign up, book and arrange itineraries, and notify the group

At first glance, these problems may seem odd, but in reality they all have the same structure.

how to say? In fact, when they are organized, you will find:

![](images/20211024113557.png)

All are: input, processing, output.

The action of "input, processing, and output" actually has a name called "process".

![](images/20211024113631.png)
![](images/20211024113637.png)
![](images/20211024113643.png)

And what we think of as programming is actually

![](images/20211024113654.png)

The average person tells an engineer that when he wants to learn to program, the focus tends to be on automation

![](images/20211024113708.png)

But what most people lack is problem decomposition + process thinking.

And when you can decompose the problem into "process", adding automatic execution becomes "automation".

![](images/20211024113726.png)

There are different languages ​​in the market, and there are different scenarios suitable for application. For example, Python is suitable for crawlers, Ruby is suitable for websites, Swift is a special language for iPhone, and JavaScript is mostly used as web page special effects.

Sometimes we solve a problem not only in one language, but maybe even in multiple languages.

But don't panic, we don't need to learn so many languages ​​to solve the things around us. More importantly, how do we find the "tools" to connect the "answers" to the various "questions" in the process.

Especially on the Internet, there are almost automatic services and suites for some of the most commonly used scenarios.

For example, if I want to translate an English book bought on the Internet into a Chinese book. There are actually several paths to choose from:

1. Looking for work-study students, look at the whole book and type it out, and then find someone to translate it into Chinese.
2. OCR the entire book, automatically scan every word in and identify it, and then find someone to translate it into Chinese.
3. Find the typed version of this book (such as epub), manually paste it into Google Translate, translate it into Chinese, and then splicing it together.
4. Divide the book into chapters, write a program to automatically send it to the Google Translate API, and complete the translation of a book in 1 minute.

Writing a program is not necessary, the key is how you find the problem and break it down. Usually people who are proficient in programming, like me, do not write programs when they encounter problems. Instead, I will find a way to disassemble the real problem, and then find all the simple, rude and feasible methods on this critical path, put it together first, and output the result I want. Then optimize each node in the process one by one, and finally achieve automation.

After you "learn programming" with this concept in mind. Usually the happiness increases a lot, because in the process, you will get mostly positive feedback (the pleasure of solving the problem). Instead of worrying about your own poor grammar, or ugly code writing.

As you become more proficient with this process, the more you understand the error messages on the program and the Google information you find.

With this concept, you can then integrate the daily problems you want to solve into our previous "problem digging", "processed" and "addiction loop".

### Treat **Errors and Feedback** with a positive mindset

Another key point in learning programming is how to treat "errors and feedback".

When I was teaching programming in the past, I noticed a peculiar phenomenon:

- If you've ever studied in an IT department, you'll learn a new programming language for work quickly
- Conversely, the failure rate is often very high

I used to think it was because of the difference in exposure to computer prep knowledge in college. Later, I only found out after chatting with more "ordinary people who want to learn programming". The point is not these computer prerequisites. But when the computer makes an error, the acceptance of the feedback processing method of the message is different.

For programmers and people who have studied in the Department of Information Science, if they are learning a new programming language, if the screen jumps out in red, there is an error. We would consider this normal feedback.

Maybe I made a typo, maybe my file is in the wrong place, just change it. But ordinary people will understand it as "I'm Loser, I keep making mistakes".

Because ordinary people have never faced such frequent and intensive "error messages" in their life.

But as programmers, when we are programming, it is not OK to write a program once. To be more precise, for professional programmers, the chance of writing a program once is 0%. Yes, you read that right, 0%.

Most programmers use Debug-Oriented Programming. It is to write a small piece of program (or copy a small piece of code from the Internet) and run violently. Then see if you have made a typo, and fix the typo if you make a typo. That's right, let's see if the small program (about 20-50 lines) just written has the expected behavior. If not, correct it, and if there is, write another paragraph.

The so-called programming behavior is that the programmer continuously writes many small code segments, then forms large code blocks, and then rearranges them.

So eating 100 errors a day is super normal. This is why IT students learn new languages ​​and new frameworks very quickly after leaving campus. Not because "they have a foundation", but because they can "ignore the trauma caused by Error" psychologically.

If beginners don't understand this, they will quickly go from getting started to giving up on the road of learning programming.

And why is programming so hard to learn and so easy to give up?

This is because many online courses, or the teacher does not give the code, the student must press pause scene by scene, trying to follow the code on the teacher's screen line by line. So it is inevitable to make a typo.
Otherwise, it is a demonstration code, either the version environment is outdated, or there is a typo in it. Students can't run.

In such a strenuous learning environment and no sense of achievement, normal people give up.

Even when I was learning programming languages, I would choose textbooks from the past one or two years and have copy-pasted textbooks with examples.

because

- The programming world is iterating so fast, it is possible to use textbooks from three or four years ago, and nothing can run.
- Learning to program with a typo can kill a novice. Even an old hand like me, learning a new language, happens, and I can't bear it.

## Observe the process and practice small routines

There are hundreds of programming languages ​​in the world. It can be said that they are the same at the bottom, but they are actually different in application scenarios.

The so-called bottom-level communication refers to

1. The construction process of method (method means that we will wrap a series of codes into a code block that can be called, so that when we encounter similar functions, we don’t need to re-copy a row, just call it directly.)
2. if / else (whatever the situation is, the result will be executed)
3. for loop (repeat a piece of code several times)

If you are really interested in learning to program and want to practice these three concepts in a relatively painless way. It is recommended to learn a set of programming games from Apple on the iPad, called Learn to Code. This set of textbooks is very well written, and children in elementary school can also get started and learn how to program on iOS.

However, each language has its own set of libraries and development processes.

For example, the Ruby on Rails website framework that I am good at is fine. The minimal basic process is CRUD.

- Create create data
- Read read rendering data
- Update update information
- Destroy delete data

Dynamic website development, mostly related to the database. So learning to build a website, knowing how to display the page (HTML), beautify the page (CSS/JavaScript), and read the change data (database) is the direction to know when developing a website.

So when you learn Ruby on Rails, the smallest unit of learning is CRUD. If you are proficient in this process, the relevant knowledge can be built up.

The main process of iOS is Screen + API.

The smallest unit of iOS is a Screen. That is, every screen (switch) of the mobile phone you look at is the smallest unit. A set of mobile phone programs is connected by countless screens.

So what you need to learn is how to build a screen one by one, and then string the screens together. And some data on the screen needs to be provided by the outside world, and the way to provide the outside world is to use the API interface. The API format may be CSV or JSON. or other formats.

In short, every language has a main process, and the "big" keywords that make up this main process.

To learn a "programming language", the point is not to memorize terminology. but

1. Deconstruct the problem you want to solve and find the right tools to solve it
2. If you can't find a suitable tool, consider finding a suitable tool language
3. Don't rush to practice according to the book or textbook, you can first observe the "process" and "keywords" of the whole language
4. Find several sets of textbooks that allow you to practice the most basic process routines. Practice this set of small procedures two or three times, and you can use a very clumsy but not "stuck" method to splice out the results you want.
5. With the continuous practice and revision of your program, your learning results will naturally improve rapidly and enter the super positive loop
